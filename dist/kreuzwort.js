// Generated by CoffeeScript 2.0.2
(function() {
  // Cursor: row, col and (writing) direction
  // Cell: an actual DOM cell
  // Word: collection of cells and corresponding clue
  var Kreuzwort, createSecretInput, english, german, hash, horizontal, standardInputCallback, standardLetters, strings, toClipboard, vertical, wordStartsToRegExp;

  horizontal = {
    toString: () => {
      return "horizontal";
    },
    advance: (cursor) => {
      if (cursor != null) {
        return {
          row: cursor.row,
          col: cursor.col + 1
        };
      } else {
        return null;
      }
    },
    retrogress: (cursor) => {
      if (cursor != null) {
        return {
          row: cursor.row,
          col: cursor.col - 1
        };
      } else {
        return null;
      }
    },
    before: 'left',
    after: 'right',
    other: null
  };

  vertical = {
    toString: () => {
      return "vertical";
    },
    advance: (cursor) => {
      if (cursor != null) {
        return {
          row: cursor.row + 1,
          col: cursor.col
        };
      } else {
        return null;
      }
    },
    retrogress: (cursor) => {
      if (cursor != null) {
        return {
          row: cursor.row - 1,
          col: cursor.col
        };
      } else {
        return null;
      }
    },
    before: 'top',
    after: 'bottom',
    other: horizontal
  };

  horizontal.other = vertical;

  hash = (string) => {
    var c, char, h, k, len;
    h = 0;
    if (string.length === 0) {
      return h;
    }
    for (k = 0, len = string.length; k < len; k++) {
      char = string[k];
      c = char.charCodeAt();
      h = ((h << 5) - h) + c;
      h = h & h; // Convert to 32bit integer
    }
    return h.toString();
  };

  toClipboard = (string) => {
    var textarea;
    textarea = document.createElement('textarea');
    textarea.value = string;
    document.body.appendChild(textarea);
    textarea.select();
    document.execCommand('copy');
    return document.body.removeChild(textarea);
  };

  createSecretInput = function(outline) {
    var secretInput;
    secretInput = document.createElement('input');
    secretInput.style['position'] = 'absolute';
    secretInput.style['margin'] = '0';
    secretInput.style['padding'] = '0';
    secretInput.style['border'] = 'none';
    secretInput.style['outline'] = `1px solid ${outline}`;
    secretInput.style['left'] = '-10000px';
    return secretInput;
  };

  standardLetters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ".split("");

  standardInputCallback = function(e) {
    if ((standardLetters.indexOf(e.key)) >= 0) {
      return [e.key.toUpperCase()];
    } else {
      return null;
    }
  };

  wordStartsToRegExp = function(starts) {
    return new RegExp((starts.join('([^]*)')) + '([^].*)');
  };

  window.fromGrid = function(grid) {
    var cell, cells, colNum, k, l, len, len1, prevCell, prevRow, row, rows, table, td, tr;
    table = document.createElement('table');
    rows = grid.trim().split('\n');
    prevRow = [];
    for (k = 0, len = rows.length; k < len; k++) {
      row = rows[k];
      tr = document.createElement('tr');
      cells = row.trim().split('');
      prevCell = '.';
      for (colNum = l = 0, len1 = cells.length; l < len1; colNum = ++l) {
        cell = cells[colNum];
        td = document.createElement('td');
        if (cell === '.') {
          td.innerHTML = '';
        } else if (cell === 'X') {
          td.innerHTML = '&nbsp;';
        } else {
          td.innerHTML = cell;
        }
        tr.appendChild(td);
        prevCell = cell;
      }
      table.appendChild(tr);
      prevRow = row;
    }
    return table;
  };

  window.tableCellMatrix = function(table) {
    var cell, col, i, j, k, l, len, len1, m, o, p, ref, ref1, ref2, ref3, row, rowElem;
    m = [];
    ref = table.rows;
    for (row = k = 0, len = ref.length; k < len; row = ++k) {
      rowElem = ref[row];
      col = 0;
      if (m[row] == null) {
        m[row] = [];
      }
      ref1 = rowElem.cells;
      for (l = 0, len1 = ref1.length; l < len1; l++) {
        cell = ref1[l];
        while (m[row][col] != null) {
          col++;
        }
        for (i = o = 0, ref2 = cell.rowSpan || 1; 0 <= ref2 ? o < ref2 : o > ref2; i = 0 <= ref2 ? ++o : --o) {
          for (j = p = 0, ref3 = cell.colSpan || 1; 0 <= ref3 ? p < ref3 : p > ref3; j = 0 <= ref3 ? ++p : --p) {
            if (m[row + i] == null) {
              m[row + i] = [];
            }
            m[row + i][col + j] = cell;
          }
        }
      }
    }
    return m;
  };

  //window.toQueryString = (string) ->
  //    params = new URLSearchParams()
  //    params.append('q', string)
  //    return params.toString().substr(2)
  strings = {
    checkSolution: 'checkSolution',
    solutionCorrect: 'solutionCorrect',
    solutionIncorrect: 'solutionIncorrect',
    reset: 'reset',
    resetConfirmation: 'resetConfirmation',
    horizontal: 'horizontal',
    vertical: 'vertical',
    showHTML: 'showHTML',
    copyHTML: 'copyHTML',
    hideHTML: 'hideHTML',
    noClue: 'noClue',
    print: 'print',
    printEmpty: 'printEmpty'
  };

  english = {
    checkSolution: 'Check Solution',
    solutionCorrect: 'The solution is correct.',
    solutionIncorrect: 'The crossword is incomplete or the solution is incorrect.',
    reset: 'Reset Crossword',
    resetConfirmation: 'Do you want to completely reset the crossword?',
    horizontal: 'Across',
    vertical: 'Down',
    showHTML: 'Show Grid HTML',
    copyHTML: 'Copy HTML to Clipboard',
    hideHTML: 'Hide Grid HTML',
    noClue: 'No clue in this direction',
    print: 'Print',
    printEmpty: 'Print Empty Grid'
  };

  german = {
    checkSolution: 'Lösung prüfen',
    solutionCorrect: 'Super, alles richtig.',
    solutionIncorrect: 'Leider ist noch nicht alles richtig.',
    reset: 'Alles löschen',
    resetConfirmation: 'Soll das Rätsel vollständig zurückgesetzt werden?',
    horizontal: 'Waagerecht',
    vertical: 'Senkrecht',
    showHTML: 'Gitter-HTML anzeigen',
    copyHTML: 'HTML in die Zwischenablage',
    hideHTML: 'Gitter-HTML ausblenden',
    noClue: 'Kein Hinweis in diese Richtung',
    print: 'Drucken',
    printEmpty: 'Leer drucken'
  };

  Kreuzwort = (function() {
    var Word;

    class Kreuzwort {
      constructor(grid1, saveId, features = Kreuzwort.featuresFull, strings1 = strings) {
        var cell, direction, elementAfterGrid, k, l, len, len1, len2, o, ref, ref1, ref2;
        this.grid = grid1;
        this.saveId = saveId;
        this.features = features;
        this.strings = strings1;
        Kreuzwort.instances.push(this);
        this.callbacks = {
          changed: [],
          input: [standardInputCallback],
          save: [this.saveV1.bind(this)],
          wordSelected: []
        };
        this.words = {
          horizontal: [],
          vertical: []
        };
        this.cellMatrix = tableCellMatrix(this.grid);
        this.previousInput = createSecretInput();
        this.previousInput.onfocus = () => {
          this.retrogressCursor();
          return this.secretInput.focus();
        };
        document.body.appendChild(this.previousInput);
        this.secretInput = createSecretInput();
        this.secretInput.onblur = () => {
          return this.blur();
        };
        document.body.appendChild(this.secretInput);
        this.nextInput = createSecretInput();
        this.nextInput.onfocus = () => {
          this.advanceCursor();
          return this.secretInput.focus();
        };
        document.body.appendChild(this.nextInput);
        ref = this.grid.querySelectorAll('td');
        for (k = 0, len = ref.length; k < len; k++) {
          cell = ref[k];
          cell.addEventListener('click', (event) => {
            if (this.isEntryCell(event.target)) {
              this.repositionSecretInputs();
              return this.focus(event.target);
            }
          });
        }
        this.renumberStartingCells();
        ref1 = [horizontal, vertical];
        for (l = 0, len1 = ref1.length; l < len1; l++) {
          direction = ref1[l];
          ref2 = this.startsForDirection(direction);
          for (o = 0, len2 = ref2.length; o < len2; o++) {
            cell = ref2[o];
            this.words[direction].push(this.wordStartingAtCellInDirection(cell, direction));
          }
        }
        elementAfterGrid = this.grid.nextSibling;
        this.cursor = null;
        this.direction = horizontal;
        this.currentWord = null;
        this.secretInput.onkeydown = (e) => {
          return this.processInput(e);
        };
        this.repositionSecretInputs();
        this.number = 0;
        this.numberTimeStamp = 0;
        this.load();
      }

      addCallback(event, callback) {
        return this.callbacks[event].push(callback);
      }

      trigger(event, data) {
        var callback, k, len, ref, results;
        ref = this.callbacks[event];
        results = [];
        for (k = 0, len = ref.length; k < len; k++) {
          callback = ref[k];
          results.push(callback(data, this));
        }
        return results;
      }

      startingCells() {
        return this.grid.querySelectorAll("td[data-clue-vertical]:not([data-clue-vertical='']),\ntd[data-clue-horizontal]:not([data-clue-horizontal=''])");
      }

      renumberStartingCells() {
        var cell, cellNumberGenerator, k, len, ref, results;
        cellNumberGenerator = (function*(exclude) {
          var num, number;
          num = 0;
          while (true) {
            num++;
            number = num.toString();
            if (!(exclude.indexOf(number) >= 0)) {
              yield number;
            }
          }
        })([]);
        ref = this.startingCells();
        results = [];
        for (k = 0, len = ref.length; k < len; k++) {
          cell = ref[k];
          results.push(cell.setAttribute('data-cell-number', cellNumberGenerator.next().value));
        }
        return results;
      }

      startsForDirection(direction) {
        return this.grid.querySelectorAll(`td[data-clue-${direction}]:not([data-clue-${direction}=''])`);
      }

      cellNumbersForDirection(direction) {
        var cell, k, len, ref, results;
        ref = this.startsForDirection(direction);
        results = [];
        for (k = 0, len = ref.length; k < len; k++) {
          cell = ref[k];
          results.push(cell.getAttribute('data-cell-number'));
        }
        return results;
      }

      fillCluesFromArrayForDirection(clues, direction) {
        var cells, clue, index, k, len, ref, results;
        cells = this.startsForDirection(direction);
        results = [];
        for (index = k = 0, len = clues.length; k < len; index = ++k) {
          clue = clues[index];
          results.push((ref = cells.item(index)) != null ? ref.setAttribute(`data-clue-${direction}`, clue) : void 0);
        }
        return results;
      }

      fillCluesFromTextForDirection(text, direction) {
        var cellNumbers, clues, re;
        cellNumbers = this.cellNumbersForDirection(direction);
        re = wordStartsToRegExp(cellNumbers);
        clues = re.exec(text).splice(1);
        return this.fillCluesFromArrayForDirection(clues, direction);
      }

      clueWordsAtLeastLong(n) {
        var cell, cellNumberGenerator, direction, k, l, len, len1, len2, number, o, ref, ref1, ref2, row, word;
        cellNumberGenerator = (function*(exclude) {
          var num, number;
          num = 0;
          while (true) {
            num++;
            number = num.toString();
            if (!(exclude.indexOf(number) >= 0)) {
              yield number;
            }
          }
        })([]);
        ref = this.grid.rows;
        for (k = 0, len = ref.length; k < len; k++) {
          row = ref[k];
          ref1 = row.cells;
          for (l = 0, len1 = ref1.length; l < len1; l++) {
            cell = ref1[l];
            ref2 = [horizontal, vertical];
            for (o = 0, len2 = ref2.length; o < len2; o++) {
              direction = ref2[o];
              word = this.wordStartingAtCellInDirection(cell, direction);
              if ((word != null) && word.cells.length >= n) {
                cell.setAttribute(`data-clue-${direction}`, '.');
                if (!cell.hasAttribute('data-cell-number')) {
                  number = cellNumberGenerator.next().value;
                  cell.setAttribute('data-cell-number', number);
                  word.number = number;
                }
                word.clue = '.';
                this.words[direction].push(word);
              }
            }
          }
        }
        return this.renumberStartingCells();
      }

      cellWithNumber(number) {
        return this.startingCells()[number - 1];
      }

      repositionSecretInputs() {
        this.nextInput.style['top'] = this.secretInput.style['top'] = this.previousInput.style['top'] = `${this.grid.offsetTop}px`;
        return this.nextInput.style['height'] = this.secretInput.style['height'] = this.previousInput.style['height'] = `${this.grid.offsetHeight}px`;
      }

      advanceCursor() {
        return this.setCursor(this.direction.advance(this.cursor));
      }

      retrogressCursor() {
        return this.setCursor(this.direction.retrogress(this.cursor));
      }

      cellAfter(cursor = this.cursor) {
        var ref;
        if (cursor != null) {
          return (ref = this.cellMatrix[cursor.row]) != null ? ref[cursor.col] : void 0;
        } else {
          return null;
        }
      }

      cellBefore(cursor = this.cursor, direction = this.direction) {
        return this.cellAfter(direction.retrogress(cursor));
      }

      cursorAt(cell) {
        return {
          row: cell.parentElement.rowIndex,
          col: cell.cellIndex
        };
      }

      getClue(cell, direction) {
        var clue;
        clue = cell != null ? cell.getAttribute(`data-clue-${direction}`) : void 0;
        return ((clue != null) && clue !== "" ? clue : null);
      }

      isEntryCell(cell) {
        return (cell != null) && cell.textContent !== "";
      }

      wordStartingAtCellInDirection(cell, direction) {
        var cells, cursor;
        if (cell == null) {
          return null;
        }
        cursor = this.cursorAt(cell);
        if (!((this.isEntryCell(cell)) && (this.isWordBorder(cursor, direction)))) {
          return null;
        }
        cells = [cell];
        cursor = direction.advance(cursor);
        while (!this.isWordBorder(cursor, direction)) {
          cells.push(this.cellAfter(cursor, direction));
          cursor = direction.advance(cursor);
        }
        return new Kreuzwort.Word(cells, this.getClue(cell, direction), cell.getAttribute('data-cell-number'), direction, cell.getAttribute(`data-explanation-${direction}`));
      }

      wordAtCell(cell, direction) {
        var k, len, ref, word;
        ref = this.words[direction];
        // TODO: This linear search should be fast enough for usual crossword sizes. However, a better data structure allowding direct access to the words of a cell would be nice anyways.
        for (k = 0, len = ref.length; k < len; k++) {
          word = ref[k];
          if (word.cells.indexOf(cell) >= 0) {
            return word;
          }
        }
        return null;
      }

      wordAfterCursor(cursor = this.cursor, direction = this.direction) {
        var searchCell;
        searchCell = this.cellAfter(cursor, direction);
        return this.wordAtCell(searchCell, direction);
      }

      wordBeforeCursor(cursor = this.cursor, direction = this.direction) {
        return this.wordAtCell(this.cellBefore(cursor, direction), direction);
      }

      clueListingForDirection(direction, includeEnumerations = true) {
        var extraInfoSpan, fn, fn1, fn2, k, len, li, ol, ref, renderExtraInfo, start, word;
        ol = document.createElement('ol');
        ref = this.words[direction];
        fn = (li) => {
          word.addCallback('selected', () => {
            return li.classList.add('current-clue');
          });
          return word.addCallback('unselected', () => {
            return li.classList.remove('current-clue');
          });
        };
        fn1 = (li) => {
          return word.addCallback('changed', (_, word) => {
            if (word.complete()) {
              return li.classList.add('complete');
            } else {
              return li.classList.remove('complete');
            }
          });
        };
        fn2 = (start) => {
          return li.onclick = () => {
            return this.focus(start, direction);
          };
        };
        for (k = 0, len = ref.length; k < len; k++) {
          word = ref[k];
          li = document.createElement('li');
          li.value = word.number;
          start = word.cells[0];
          fn(li);
          li.innerHTML = word.clue;
          if (word.complete()) {
            li.classList.add('complete');
          }
          fn1(li);
          if (includeEnumerations) {
            li.appendChild(document.createTextNode(' '));
            extraInfoSpan = document.createElement('span');
            extraInfoSpan.className = 'extra-info';
            renderExtraInfo = function(span, word) {
              if (word.empty()) {
                return span.innerHTML = `(${word.length})`;
              } else {
                return span.innerHTML = `(${word.length}<span>, ${word}</span>)`;
              }
            };
            renderExtraInfo(extraInfoSpan, word);
            li.appendChild(extraInfoSpan);
            ((extraInfoSpan) => {
              return word.addCallback('changed', (data, word) => {
                return renderExtraInfo(extraInfoSpan, word);
              });
            })(extraInfoSpan);
          }
          fn2(start);
          ol.appendChild(li);
        }
        return ol;
      }

      blur(fullBlur = false) {
        var cell, k, len, ref;
        if (fullBlur && (this.currentWord != null)) {
          ref = this.currentWord.cells;
          for (k = 0, len = ref.length; k < len; k++) {
            cell = ref[k];
            cell.classList.remove("current-word");
          }
        }
      }

      hasFocus() {
        return this.secretInput === document.activeElement;
      }

      isWordBorder(cursor, direction = this.direction) {
        var afterCell, beforeCell;
        beforeCell = this.cellBefore(cursor, direction);
        afterCell = this.cellAfter(cursor, direction);
        return (afterCell != null ? afterCell.hasAttribute(`data-clue-${direction}`) : void 0) || !this.isEntryCell(afterCell) || !this.isEntryCell(beforeCell);
      }

      setCursor(cursor, direction = this.direction) {
        var cell, k, len, newWord, ref, ref1, ref2, ref3, ref4, ref5, ref6, ref7;
        if ((ref = this.cellAfter()) != null) {
          ref.classList.remove("cursor-top", "cursor-left");
        }
        if ((ref1 = this.cellBefore()) != null) {
          ref1.classList.remove("cursor-bottom", "cursor-right");
        }
        this.cursor = cursor;
        this.direction = direction;
        if ((ref2 = this.cellAfter()) != null) {
          ref2.classList.add(`cursor-${direction.before}`);
        }
        if ((ref3 = this.cellBefore()) != null) {
          ref3.classList.add(`cursor-${direction.after}`);
        }
        newWord = this.wordAfterCursor(cursor, direction);
        if (newWord === this.currentWord) {
          return;
        }
        this.blur(true);
        if ((ref4 = this.currentWord) != null) {
          ref4.trigger('unselected');
        }
        this.currentWord = newWord;
        if (((ref5 = this.currentWord) != null ? ref5.clue : void 0) != null) {
          ref6 = this.currentWord.cells;
          for (k = 0, len = ref6.length; k < len; k++) {
            cell = ref6[k];
            cell.classList.add('current-word');
          }
        }
        if ((ref7 = this.currentWord) != null) {
          ref7.trigger('selected');
        }
        this.trigger('wordSelected', this.currentWord);
      }

      focus(cell, newDirection) {
        var cursor, ref, ref1, wordOnlyInOtherDirection, wordStartOnlyInOtherDirection;
        cursor = this.cursorAt(cell);
        if (newDirection == null) {
          wordOnlyInOtherDirection = (((ref = this.wordAfterCursor(cursor, this.direction)) != null ? ref.clue : void 0) == null) && (((ref1 = this.wordAfterCursor(cursor, this.direction.other)) != null ? ref1.clue : void 0) != null);
          wordStartOnlyInOtherDirection = (this.getClue(cell, this.direction) == null) && (this.getClue(cell, this.direction.other) != null);
          if (cell === this.cellAfter() || wordOnlyInOtherDirection || wordStartOnlyInOtherDirection) {
            newDirection = this.direction.other;
          } else {
            newDirection = this.direction;
          }
        }
        this.setCursor(cursor, newDirection);
        this.secretInput.focus();
      }

      cellChanged(cell) {
        var ref, ref1;
        this.trigger('changed');
        if ((ref = this.wordAtCell(cell, horizontal)) != null) {
          ref.trigger('changed');
        }
        return (ref1 = this.wordAtCell(cell, vertical)) != null ? ref1.trigger('changed') : void 0;
      }

      processInput(e) {
        var attr, callbackResult, cell, entry, inputProcessed, k, l, len, len1, nextWord, preserveNumber, preventDefault, ref, ref1, wordIndex;
        if (e.metaKey || e.ctrlKey) {
          return;
        }
        preventDefault = true;
        preserveNumber = false;
        inputProcessed = false;
        ref = this.trigger('input', {
          key: e.key
        }).reverse();
        for (k = 0, len = ref.length; k < len; k++) {
          callbackResult = ref[k];
          if (callbackResult != null) {
            inputProcessed = true;
            for (l = 0, len1 = callbackResult.length; l < len1; l++) {
              entry = callbackResult[l];
              cell = this.cellAfter();
              if ((this.isEntryCell(cell)) || this.features.writeNewCells) {
                cell.textContent = entry;
                this.cellChanged(cell);
                this.advanceCursor();
              }
            }
            break;
          }
        }
        if (!inputProcessed) {
          if (("0" <= (ref1 = e.key) && ref1 <= "9")) {
            preserveNumber = true;
            if (e.timeStamp - this.numberTimeStamp > 1000) {
              this.number = 0;
            }
            this.numberTimeStamp = e.timeStamp;
            this.number *= 10;
            this.number += parseInt(e.key);
            if ((cell = this.cellWithNumber(this.number)) != null) {
              this.focus(cell);
            }
          } else {
            switch (e.key) {
              case ' ':
                this.setCursor(this.cursor, this.direction.other);
                break;
              case 'ArrowRight':
                this.setCursor(horizontal.advance(this.cursor));
                break;
              case 'ArrowLeft':
                this.setCursor(horizontal.retrogress(this.cursor));
                break;
              case 'ArrowUp':
                this.setCursor(vertical.retrogress(this.cursor));
                break;
              case 'ArrowDown':
                this.setCursor(vertical.advance(this.cursor));
                break;
              case 'Tab':
                // TODO: Make this nicer. What if no word is currently selected? Probably, the last word was completed, but a new word did not start immediately (end of line or bloek or non-perfect grid). Tab should jump to the next word.
                wordIndex = this.words[this.currentWord.direction].indexOf(this.currentWord);
                wordIndex += e.shiftKey ? -1 : 1;
                nextWord = (0 <= wordIndex && wordIndex < this.words[this.currentWord.direction].length) ? this.words[this.currentWord.direction][wordIndex] : this.words[this.currentWord.direction.other].length > 0 ? wordIndex >= 0 ? this.words[this.currentWord.direction.other][0] : this.words[this.currentWord.direction.other][this.words[this.currentWord.direction.other].length - 1] : this.words[this.currentWord.direction][0];
                this.focus(nextWord.cells[0], nextWord.direction);
                break;
              case 'Backspace':
                cell = this.cellBefore();
                if (this.isEntryCell(cell)) {
                  cell.innerHTML = '&nbsp;';
                  this.cellChanged(cell);
                  this.retrogressCursor();
                }
                break;
              case 'Enter':
                if (this.features.setBars) {
                  cell = this.cellAfter();
                  attr = `data-clue-${this.direction}`;
                  switch (cell.getAttribute(attr)) {
                    case '':
                      cell.removeAttribute(attr);
                      break;
                    case null:
                      cell.setAttribute(attr, '.');
                      break;
                    default:
                      cell.setAttribute(attr, '');
                  }
                } else {
                  preventDefault = false;
                }
                break;
              case 'Delete':
                if (this.features.writeNewCells) {
                  cell = this.cellAfter();
                  cell.innerHTML = '';
                  this.cellChanged(cell);
                  this.advanceCursor();
                } else {
                  preventDefault = false;
                }
                break;
              default:
                preventDefault = false;
            }
          }
        }
        this.save();
        if (preventDefault) {
          e.preventDefault();
        }
        if (!preserveNumber) {
          return this.number = 0;
        }
      }

      clear(clearStorage = true) {
        var cell, k, len, ref;
        ref = this.grid.querySelectorAll('td:not(:empty)');
        for (k = 0, len = ref.length; k < len; k++) {
          cell = ref[k];
          cell.innerHTML = "&nbsp;";
        }
        if (clearStorage) {
          try {
            localStorage.removeItem(`coffeeword-${this.saveId}-v1`);
          } catch (error) {

          }
        }
      }

      populateClues() {
        var cell, k, len, ref;
        ref = this.startingCells();
        for (k = 0, len = ref.length; k < len; k++) {
          cell = ref[k];
          if (cell.getAttribute("data-clue-vertical") === '.') {
            cell.setAttribute("data-clue-vertical", this.wordStartingAtCellInDirection(cell, vertical));
          }
          if (cell.getAttribute("data-clue-horizontal") === '.') {
            cell.setAttribute("data-clue-horizontal", this.wordStartingAtCellInDirection(cell, horizontal));
          }
        }
      }

      saveV1() {
        var cell, e, row, saveString;
        saveString = ((function() {
          var k, len, ref, results;
          ref = this.grid.rows;
          results = [];
          for (k = 0, len = ref.length; k < len; k++) {
            row = ref[k];
            results.push(((function() {
              var l, len1, ref1, results1;
              ref1 = row.cells;
              results1 = [];
              for (l = 0, len1 = ref1.length; l < len1; l++) {
                cell = ref1[l];
                results1.push(cell.textContent);
              }
              return results1;
            })()).join(','));
          }
          return results;
        }).call(this)).join(';');
        try {
          localStorage.setItem(`coffeeword-${this.saveId}-v1`, saveString);
        } catch (error) {
          e = error;
        }
        return saveString;
      }

      saveV2() {
        var cell, row, saveString;
        return saveString = ((function() {
          var k, len, ref, results;
          ref = this.grid.rows;
          results = [];
          for (k = 0, len = ref.length; k < len; k++) {
            row = ref[k];
            results.push(((function() {
              var l, len1, ref1, results1;
              ref1 = row.cells;
              results1 = [];
              for (l = 0, len1 = ref1.length; l < len1; l++) {
                cell = ref1[l];
                switch (cell.textContent) {
                  case ' ':
                    results1.push('_');
                    break;
                  case '':
                    results1.push('.');
                    break;
                  default:
                    results1.push(cell.textContent);
                }
              }
              return results1;
            })()).join(''));
          }
          return results;
        }).call(this)).join('-');
      }

      loadV1(string) {
        var cellString, col, k, l, len, len1, ref, ref1, row, rowString;
        ref = string.split(';');
        for (row = k = 0, len = ref.length; k < len; row = ++k) {
          rowString = ref[row];
          ref1 = rowString.split(',');
          for (col = l = 0, len1 = ref1.length; l < len1; col = ++l) {
            cellString = ref1[col];
            this.cellAfter({row, col}).textContent = cellString;
          }
        }
      }

      loadV2(string) {
        var cellString, col, k, l, len, len1, ref, ref1, row, rowString;
        ref = string.split('-');
        for (row = k = 0, len = ref.length; k < len; row = ++k) {
          rowString = ref[row];
          ref1 = rowString.split('');
          for (col = l = 0, len1 = ref1.length; l < len1; col = ++l) {
            cellString = ref1[col];
            this.cellAfter({row, col}).textContent = (function() {
              switch (cellString) {
                case '_':
                  return ' ';
                case '.':
                  return '';
                default:
                  return cellString;
              }
            })();
          }
        }
      }

      save() {
        return this.trigger('save');
      }

      load() {
        var e, params;
        try {
          params = new URL(location).searchParams;
          if (params.has(`${this.saveId}-v2`)) {
            return this.loadV2(params.get(`${this.saveId}-v2`));
          } else if (params.has(`${this.saveId}-v1`)) {
            return this.loadV1(params.get(`${this.saveId}-v1`));
          } else {
            return this.loadV1(localStorage.getItem(`coffeeword-${this.saveId}-v1`));
          }
        } catch (error) {
          e = error;
          return console.log(e);
        }
      }

      progressURL() {
        var url;
        url = new URL(location);
        url.searchParams.set(`${this.saveId}-v2`, this.saveV2());
        return url;
      }

      check() {
        var solutionHash;
        solutionHash = this.grid.getAttribute('data-solution-hash-v1');
        return solutionHash === this.currentHash();
      }

      currentHash() {
        return hash(this.saveV1());
      }

      gridHTML() {
        var html, temp;
        this.blur();
        this.grid.setAttribute('data-solution-hash-v1', this.currentHash());
        this.populateClues();
        temp = this.saveV1();
        this.clear(false);
        html = this.grid.outerHTML;
        this.loadV1(temp);
        return html;
      }

    };

    Kreuzwort.Word = Word = class Word {
      constructor(cells1, clue1, number1, direction1, explanation) {
        this.cells = cells1;
        this.clue = clue1;
        this.number = number1;
        this.direction = direction1;
        this.explanation = explanation;
        this.callbacks = {
          changed: [],
          selected: [],
          unselected: []
        };
        this.length = this.cells.length;
      }

      addCallback(event, callback) {
        return this.callbacks[event].push(callback);
      }

      trigger(event, data) {
        var callback, k, len, ref, results;
        ref = this.callbacks[event];
        results = [];
        for (k = 0, len = ref.length; k < len; k++) {
          callback = ref[k];
          results.push(callback(data, this));
        }
        return results;
      }

      toString() {
        var cell, unsolved;
        return ((function() {
          var k, len, ref, results;
          ref = this.cells;
          results = [];
          for (k = 0, len = ref.length; k < len; k++) {
            cell = ref[k];
            if (cell.innerHTML === '&nbsp;') {
              results.push('␣');
            } else {
              unsolved = false;
              results.push(cell.innerHTML);
            }
          }
          return results;
        }).call(this)).join('');
      }

      empty() {
        var cell, k, len, ref;
        ref = this.cells;
        for (k = 0, len = ref.length; k < len; k++) {
          cell = ref[k];
          if (cell.textContent !== ' ') {
            return false;
          }
        }
        return true;
      }

      complete() {
        var cell, k, len, ref;
        ref = this.cells;
        for (k = 0, len = ref.length; k < len; k++) {
          cell = ref[k];
          if (cell.textContent === ' ') {
            return false;
          }
        }
        return true;
      }

    };

    Kreuzwort.instances = [];

    Kreuzwort.featuresFull = {
      writeNewCells: false,
      setBars: false
    };

    Kreuzwort.featuresCompact = {
      writeNewCells: false,
      setBars: false
    };

    Kreuzwort.featuresConstruction = {
      writeNewCells: true,
      setBars: true
    };

    Kreuzwort.languages = {
      english: english,
      german: german
    };

    Kreuzwort.horizontal = horizontal;

    Kreuzwort.vertical = vertical;

    return Kreuzwort;

  })();

  window.Kreuzwort = Kreuzwort;

  window.kreuzwortAutoSetup = (container) => {
    var checkButton, clearButton, controlsDiv, createButton, currentClueDiv, direction, directions, elementAfterGrid, grid, head, k, kreuzwort, len, localStrings, printEmptyButton, printFullButton;
    grid = container.querySelector('table');
    elementAfterGrid = grid.nextElementSibling;
    kreuzwort = new Kreuzwort(grid, container.id, Kreuzwort.featuresFull);
    // TODO: Better way to choose this automatically (HTML lang attribute?)
    localStrings = german;
    currentClueDiv = document.createElement('p');
    currentClueDiv.className = 'current-clue';
    currentClueDiv.hidden = true;
    kreuzwort.addCallback('wordSelected', (word) => {
      currentClueDiv.innerHTML = (word != null ? word.clue : void 0) != null ? `<span class="current-word-position">\n    ${localStrings[word.direction]}, ${word.number}\n</span>\n${word.clue}` : `<i>${localStrings.noClue}</i>`;
      return currentClueDiv.hidden = false;
    });
    container.insertBefore(currentClueDiv, elementAfterGrid);
    controlsDiv = document.createElement('div');
    controlsDiv.className = 'controls';
    checkButton = document.createElement('button');
    checkButton.textContent = localStrings.checkSolution;
    checkButton.addEventListener('click', () => {
      if (kreuzwort.check()) {
        return alert(localStrings.solutionCorrect);
      } else {
        return alert(localStrings.solutionIncorrect);
      }
    });
    controlsDiv.append(checkButton);
    controlsDiv.append(' ');
    clearButton = document.createElement('button');
    clearButton.textContent = localStrings.reset;
    clearButton.addEventListener('click', () => {
      if (confirm(localStrings.resetConfirmation)) {
        return kreuzwort.clear();
      }
    });
    controlsDiv.append(clearButton);
    controlsDiv.append(' ');
    if (!container.classList.contains('compact')) {
      printEmptyButton = document.createElement('button');
      printEmptyButton.textContent = localStrings.printEmpty;
      printEmptyButton.addEventListener('click', () => {
        var temp;
        temp = kreuzwort.saveV1();
        kreuzwort.clear();
        window.print();
        return Promise.resolve().then(() => {
          kreuzwort.loadV1(temp);
          return kreuzwort.save();
        });
      });
      controlsDiv.append(printEmptyButton);
      controlsDiv.append(' ');
      printFullButton = document.createElement('button');
      printFullButton.textContent = localStrings.print;
      printFullButton.addEventListener('click', () => {
        return window.print();
      });
      controlsDiv.append(printFullButton);
      controlsDiv.append(' ');
    }
    if (container.classList.contains('construction')) {
      createButton = document.createElement('button');
      createButton.textContent = localStrings.copyHTML;
      createButton.addEventListener('click', () => {
        return toClipboard(kreuzwort.gridHTML());
      });
      controlsDiv.append(createButton);
      controlsDiv.append(' ');
    }
    if (controlsDiv.hasChildNodes()) {
      container.insertBefore(controlsDiv, elementAfterGrid);
    }
    if (!container.classList.contains('compact')) {
      directions = [horizontal, vertical];
      for (k = 0, len = directions.length; k < len; k++) {
        direction = directions[k];
        head = document.createElement('h2');
        head.textContent = localStrings[direction];
        container.insertBefore(head, elementAfterGrid);
        container.insertBefore(kreuzwort.clueListingForDirection(direction), elementAfterGrid);
      }
    }
    return kreuzwort;
  };

  window.addEventListener('load', () => {
    return document.querySelectorAll('.kreuzwort').forEach(kreuzwortAutoSetup);
  });

}).call(this);

// Generated by CoffeeScript 2.0.2
(function() {
  // Cursor: row, col and (writing) direction
  // Cell: an actual DOM cell
  // Word: collection of cells and corresponding hint
  var Kreuzwort, createSecretInput, english, german, hash, horizontal, standardKeyProcess, standardLetters, strings, toClipboard, vertical;

  horizontal = {
    toString: () => {
      return "horizontal";
    },
    //display: 'Waagerecht'
    advance: (cursor) => {
      if (cursor != null) {
        return {
          row: cursor.row,
          col: cursor.col + 1
        };
      } else {
        return null;
      }
    },
    retrogress: (cursor) => {
      if (cursor != null) {
        return {
          row: cursor.row,
          col: cursor.col - 1
        };
      } else {
        return null;
      }
    },
    before: 'left',
    after: 'right',
    other: null
  };

  vertical = {
    toString: () => {
      return "vertical";
    },
    //display: 'Senkrecht'
    advance: (cursor) => {
      if (cursor != null) {
        return {
          row: cursor.row + 1,
          col: cursor.col
        };
      } else {
        return null;
      }
    },
    retrogress: (cursor) => {
      if (cursor != null) {
        return {
          row: cursor.row - 1,
          col: cursor.col
        };
      } else {
        return null;
      }
    },
    before: 'top',
    after: 'bottom',
    other: horizontal
  };

  horizontal.other = vertical;

  hash = (string) => {
    var c, char, h, i, len;
    h = 0;
    if (string.length === 0) {
      return h;
    }
    for (i = 0, len = string.length; i < len; i++) {
      char = string[i];
      c = char.charCodeAt();
      h = ((h << 5) - h) + c;
      h = h & h; // Convert to 32bit integer
    }
    return h.toString();
  };

  toClipboard = (string) => {
    var textarea;
    textarea = document.createElement('textarea');
    textarea.value = string;
    document.body.appendChild(textarea);
    textarea.select();
    document.execCommand('copy');
    return document.body.removeChild(textarea);
  };

  createSecretInput = function(outline) {
    var secretInput;
    secretInput = document.createElement('input');
    secretInput.style['position'] = 'absolute';
    secretInput.style['margin'] = '0';
    secretInput.style['padding'] = '0';
    secretInput.style['border'] = 'none';
    secretInput.style['outline'] = `1px solid ${outline}`;
    //secretInput.style['z-index'] = '-1'
    secretInput.style['left'] = '-10000px';
    return secretInput;
  };

  standardLetters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ".split("");

  standardKeyProcess = function(key) {
    if ((standardLetters.indexOf(key)) >= 0) {
      return [key.toUpperCase()];
    } else {
      return null;
    }
  };

  strings = {
    checkSolution: 'checkSolution',
    solutionCorrect: 'solutionCorrect',
    solutionIncorrect: 'solutionIncorrect',
    reset: 'reset',
    resetConfirmation: 'resetConfirmation',
    horizontal: 'horizontal',
    vertical: 'vertical',
    showHTML: 'showHTML',
    copyHTML: 'copyHTML',
    hideHTML: 'hideHTML',
    noHint: 'noHint',
    print: 'print',
    printEmpty: 'printEmpty'
  };

  english = {
    checkSolution: 'Check Solution',
    solutionCorrect: 'The solution is correct.',
    solutionIncorrect: 'The crossword is incomplete or the solution is incorrect.',
    reset: 'Reset Crossword',
    resetConfirmation: 'Do you want to completely reset the crossword?',
    horizontal: 'Across',
    vertical: 'Down',
    showHTML: 'Show Grid HTML',
    copyHTML: 'Copy HTML to Clipboard',
    hideHTML: 'Hide Grid HTML',
    noHint: 'There is no hint in this direction.',
    print: 'Print',
    printEmpty: 'Print Empty Grid'
  };

  german = {
    checkSolution: 'Lösung prüfen',
    solutionCorrect: 'Super, alles richtig.',
    solutionIncorrect: 'Leider ist noch nicht alles richtig.',
    reset: 'Alles löschen',
    resetConfirmation: 'Soll das Rätsel vollständig zurückgesetzt werden?',
    horizontal: 'Waagerecht',
    vertical: 'Senkrecht',
    showHTML: 'Gitter-HTML anzeigen',
    copyHTML: 'HTML in die Zwischenablage',
    hideHTML: 'Gitter-HTML ausblenden',
    noHint: 'Kein Hinweis in diese Richtung.',
    print: 'Drucken',
    printEmpty: 'Leer drucken'
  };

  Kreuzwort = (function() {
    class Kreuzwort {
      constructor(container, features = Kreuzwort.featuresFull, strings1 = strings) {
        var cell, cellNumber, checkButton, clearButton, controlsDiv, createButton, direction, directions, elementAfterGrid, firstFeature, fn, fn1, head, hintLists, i, j, k, l, len, len1, len2, len3, printEmptyButton, printFullButton, ref, ref1;
        this.container = container;
        this.features = features;
        this.strings = strings1;
        this.grid = this.container.querySelector('table');
        this.previousInput = createSecretInput('purple');
        this.previousInput.onfocus = () => {
          this.retrogressCursor();
          return this.secretInput.focus();
        };
        this.container.insertBefore(this.previousInput, this.grid);
        this.secretInput = createSecretInput('red');
        this.secretInput.onblur = () => {
          return this.blur();
        };
        this.container.insertBefore(this.secretInput, this.grid);
        this.nextInput = createSecretInput('navy');
        this.nextInput.onfocus = () => {
          this.advanceCursor();
          return this.secretInput.focus();
        };
        this.container.insertBefore(this.nextInput, this.grid);
        ref = this.grid.querySelectorAll('td');
        fn = (cell) => {
          return cell.onclick = () => {
            if (this.isEntryCell(cell)) {
              this.repositionSecretInputs();
              return this.focus(cell);
            }
          };
        };
        for (i = 0, len = ref.length; i < len; i++) {
          cell = ref[i];
          fn(cell);
        }
        elementAfterGrid = this.grid.nextSibling;
        this.currentHintDiv = document.createElement('div');
        this.currentHintDiv.className = 'current-hint';
        this.currentHintDiv.hidden = true;
        this.container.insertBefore(this.currentHintDiv, elementAfterGrid);
        controlsDiv = document.createElement('div');
        controlsDiv.className = 'controls';
        firstFeature = true;
        if (this.features.check) {
          if (firstFeature) {
            firstFeature = false;
          } else {
            controlsDiv.append(' • ');
          }
          checkButton = document.createElement('a');
          checkButton.textContent = this.strings.checkSolution;
          checkButton.onclick = () => {
            if (this.check()) {
              return alert(this.strings.solutionCorrect);
            } else {
              return alert(this.strings.solutionIncorrect);
            }
          };
          controlsDiv.append(checkButton);
        }
        if (this.features.clear) {
          if (firstFeature) {
            firstFeature = false;
          } else {
            controlsDiv.append(' • ');
          }
          clearButton = document.createElement('a');
          clearButton.textContent = this.strings.reset;
          clearButton.onclick = () => {
            if (confirm(this.strings.resetConfirmation)) {
              return this.clear();
            }
          };
          controlsDiv.append(clearButton);
        }
        if (this.features.print) {
          if (firstFeature) {
            firstFeature = false;
          } else {
            controlsDiv.append(' • ');
          }
          printFullButton = document.createElement('a');
          printFullButton.textContent = this.strings.print;
          printFullButton.onclick = () => {
            return window.print();
          };
          controlsDiv.append(printFullButton);
          controlsDiv.append(' • ');
          printEmptyButton = document.createElement('a');
          printEmptyButton.textContent = this.strings.printEmpty;
          printEmptyButton.onclick = () => {
            var temp;
            temp = this.saveV1();
            this.clear();
            window.print();
            return window.setTimeout((() => {
              this.loadV1(temp);
              return this.save();
            }), 1);
          };
          controlsDiv.append(printEmptyButton);
        }
        if (this.features.createGrid) {
          if (firstFeature) {
            firstFeature = false;
          } else {
            controlsDiv.append(' • ');
          }
          createButton = document.createElement('a');
          createButton.textContent = this.strings.copyHTML;
          createButton.onclick = () => {
            return toClipboard(this.gridHTML());
          };
          controlsDiv.append(createButton);
        }
        if (controlsDiv.hasChildNodes()) {
          this.container.insertBefore(controlsDiv, elementAfterGrid);
        }
        if (this.features.hintListing) {
          directions = [horizontal, vertical];
          hintLists = {};
          for (j = 0, len1 = directions.length; j < len1; j++) {
            direction = directions[j];
            head = document.createElement('h2');
            head.textContent = this.strings[direction];
            this.container.insertBefore(head, elementAfterGrid);
            hintLists[direction] = document.createElement('ol');
            this.container.insertBefore(hintLists[direction], elementAfterGrid);
          }
          cellNumber = 0;
          ref1 = this.startingCells();
          for (k = 0, len2 = ref1.length; k < len2; k++) {
            cell = ref1[k];
            cellNumber++;
            fn1 = (cell, direction) => {
              var hint, li;
              hint = cell.getAttribute(`data-hint-${direction}`);
              if ((hint != null) && hint !== "") {
                li = document.createElement('li');
                li.value = cellNumber.toString();
                li.innerHTML = hint;
                li.onclick = () => {
                  this.grid.scrollIntoView();
                  return this.focus(cell, direction);
                };
                return hintLists[direction].append(li);
              }
            };
            for (l = 0, len3 = directions.length; l < len3; l++) {
              direction = directions[l];
              fn1(cell, direction);
            }
          }
        }
        this.cursor = null;
        this.direction = horizontal;
        this.currentWord = [];
        this.container.onkeydown = (e) => {
          return this.processInput(e);
        };
        this.number = 0;
        this.numberTimeStamp = 0;
        this.keyProcess = standardKeyProcess;
        this.load();
      }

      startingCells() {
        return this.grid.querySelectorAll("td[data-hint-vertical]:not([data-hint-vertical='']),\ntd[data-hint-horizontal]:not([data-hint-horizontal=''])");
      }

      cellWithNumber(number) {
        return this.startingCells()[number - 1];
      }

      repositionSecretInputs() {
        this.nextInput.style['top'] = this.secretInput.style['top'] = this.previousInput.style['top'] = `${this.grid.offsetTop}px`;
        return this.nextInput.style['height'] = this.secretInput.style['height'] = this.previousInput.style['height'] = `${this.grid.offsetHeight}px`;
      }

      advanceCursor() {
        return this.setCursor(this.direction.advance(this.cursor));
      }

      retrogressCursor() {
        return this.setCursor(this.direction.retrogress(this.cursor));
      }

      cellAfter(cursor = this.cursor) {
        var ref;
        if (cursor != null) {
          return (ref = this.grid.rows[cursor.row]) != null ? ref.cells[cursor.col] : void 0;
        } else {
          return null;
        }
      }

      cellBefore(cursor = this.cursor, direction = this.direction) {
        return this.cellAfter(direction.retrogress(cursor));
      }

      cursorAt(cell) {
        return {
          row: cell.parentElement.rowIndex,
          col: cell.cellIndex
        };
      }

      hasHint(cell, direction) {
        var hint;
        hint = cell != null ? cell.getAttribute(`data-hint-${direction}`) : void 0;
        return (hint != null) && hint !== "";
      }

      isEntryCell(cell) {
        return (cell != null) && cell.textContent !== "";
      }

      wordAfterCursor(cursor = this.cursor, direction = this.direction) {
        var cells, startingCell;
        while (!this.isWordBorder(cursor, direction)) {
          cursor = direction.retrogress(cursor);
        }
        startingCell = this.cellAfter(cursor, direction);
        if (!((this.isEntryCell(startingCell)) && this.hasHint(startingCell, direction))) {
          return [];
        }
        cells = [startingCell];
        cursor = direction.advance(cursor);
        while (!this.isWordBorder(cursor, direction)) {
          cells.push(this.cellAfter(cursor, direction));
          cursor = direction.advance(cursor);
        }
        return cells;
      }

      blur(fullBlur = false) {
        var cell, i, len, ref, ref1, ref2;
        if ((ref = this.cellAfter()) != null) {
          ref.classList.remove("cursor-top", "cursor-left");
        }
        if ((ref1 = this.cellBefore()) != null) {
          ref1.classList.remove("cursor-bottom", "cursor-right");
        }
        window.setTimeout((() => {
          if (!this.hasFocus()) {
            return this.cursor = null;
          }
        }), 10);
        if (fullBlur) {
          ref2 = this.currentWord;
          for (i = 0, len = ref2.length; i < len; i++) {
            cell = ref2[i];
            cell.classList.remove("current-word");
          }
          window.setTimeout((() => {
            if (!this.hasFocus()) {
              return this.currentHintDiv.hidden = true;
            }
          }), 10);
        }
      }

      hasFocus() {
        return this.secretInput === document.activeElement;
      }

      isWordBorder(cursor, direction = this.direction) {
        var afterCell, beforeCell;
        beforeCell = this.cellBefore(cursor, direction);
        afterCell = this.cellAfter(cursor, direction);
        return (afterCell != null ? afterCell.hasAttribute(`data-hint-${direction}`) : void 0) || !this.isEntryCell(afterCell) || !this.isEntryCell(beforeCell);
      }

      getHint(cell, direction) {
        var hint, hintIndex, i, index, len, otherCell, ref;
        hint = cell != null ? cell.getAttribute(`data-hint-${direction}`) : void 0;
        if ((hint != null) && hint !== "") {
          // TODO: Bessere Lösung
          hintIndex = -1;
          ref = this.startingCells();
          for (index = i = 0, len = ref.length; i < len; index = ++i) {
            otherCell = ref[index];
            if (otherCell === cell) {
              hintIndex = index;
            }
          }
          return `<span class="current-hint-position">\n    ${this.strings[direction]}, ${hintIndex + 1}\n</span>\n${hint}`;
        } else {
          return `<i>${this.strings.noHint}</i>`;
        }
      }

      setCursor(cursor, direction = this.direction) {
        var cell, i, len, ref, ref1, ref2, ref3;
        this.blur(true);
        this.cursor = cursor;
        this.direction = direction;
        this.currentWord = this.wordAfterCursor(cursor, direction);
        if (this.currentWord != null) {
          ref = this.currentWord;
          for (i = 0, len = ref.length; i < len; i++) {
            cell = ref[i];
            cell.classList.add('current-word');
          }
        }
        if ((ref1 = this.cellAfter()) != null) {
          ref1.classList.add(`cursor-${direction.before}`);
        }
        if ((ref2 = this.cellBefore()) != null) {
          ref2.classList.add(`cursor-${direction.after}`);
        }
        this.currentHintDiv.innerHTML = this.getHint((ref3 = this.currentWord) != null ? ref3[0] : void 0, direction);
        this.currentHintDiv.hidden = false;
      }

      focus(cell, newDirection) {
        var cursor, hintStartOnlyInOtherDirection, wordOnlyInOtherDirection;
        cursor = this.cursorAt(cell);
        if (newDirection == null) {
          wordOnlyInOtherDirection = this.wordAfterCursor(cursor, this.direction).length === 0 && this.wordAfterCursor(cursor, this.direction.other).length > 0;
          hintStartOnlyInOtherDirection = !this.hasHint(cell, this.direction) && this.hasHint(cell, this.direction.other);
          if (cell === this.cellAfter() || wordOnlyInOtherDirection || hintStartOnlyInOtherDirection) {
            newDirection = this.direction.other;
          } else {
            newDirection = this.direction;
          }
        }
        this.setCursor(cursor, newDirection);
        this.secretInput.focus();
      }

      processInput(e) {
        var attr, cell, entries, entry, i, len, preserveNumber, preventDefault, ref;
        if (e.metaKey || e.ctrlKey) {
          return;
        }
        preventDefault = true;
        preserveNumber = false;
        if ((entries = this.keyProcess(e.key)) != null) {
          for (i = 0, len = entries.length; i < len; i++) {
            entry = entries[i];
            cell = this.cellAfter();
            if ((this.isEntryCell(cell)) || this.features.writeNewCells) {
              cell.textContent = entry;
              this.advanceCursor();
            }
          }
        } else if (("0" <= (ref = e.key) && ref <= "9")) {
          preserveNumber = true;
          if (e.timeStamp - this.numberTimeStamp > 1000) {
            this.number = 0;
          }
          this.numberTimeStamp = e.timeStamp;
          this.number *= 10;
          this.number += parseInt(e.key);
          if ((cell = this.cellWithNumber(this.number)) != null) {
            this.focus(cell);
          }
        } else {
          switch (e.key) {
            case ' ':
              cell = this.cellAfter();
              if ((this.isEntryCell(cell)) || this.features.writeNewCells) {
                cell.innerHTML = "&nbsp;";
                this.advanceCursor();
              }
              break;
            case 'ArrowRight':
              this.setCursor(horizontal.advance(this.cursor));
              break;
            case 'ArrowLeft':
              this.setCursor(horizontal.retrogress(this.cursor));
              break;
            case 'ArrowUp':
              this.setCursor(vertical.retrogress(this.cursor));
              break;
            case 'ArrowDown':
              this.setCursor(vertical.advance(this.cursor));
              break;
            case 'Tab':
              this.setCursor(this.cursor, this.direction.other);
              break;
            case 'Backspace':
              cell = this.cellBefore();
              if (this.isEntryCell(cell)) {
                cell.innerHTML = '&nbsp;';
                this.retrogressCursor();
              }
              break;
            case 'Enter':
              if (this.features.setBars) {
                cell = this.cellAfter();
                attr = `data-hint-${this.direction}`;
                switch (cell.getAttribute(attr)) {
                  case '':
                    cell.removeAttribute(attr);
                    break;
                  case null:
                    cell.setAttribute(attr, '.');
                    break;
                  default:
                    cell.setAttribute(attr, '');
                }
              } else {
                preventDefault = false;
              }
              break;
            case 'Delete':
              if (this.features.writeNewCells) {
                cell = this.cellAfter();
                cell.innerHTML = '';
                this.advanceCursor();
              } else {
                preventDefault = false;
              }
              break;
            default:
              preventDefault = false;
          }
        }
        this.save();
        if (preventDefault) {
          e.preventDefault();
        }
        if (!preserveNumber) {
          return this.number = 0;
        }
      }

      clear(clearStorage = true) {
        var cell, i, len, ref;
        ref = this.grid.querySelectorAll('td:not(:empty)');
        for (i = 0, len = ref.length; i < len; i++) {
          cell = ref[i];
          cell.innerHTML = "&nbsp;";
        }
        if (clearStorage) {
          try {
            localStorage.removeItem(`coffeeword-${this.container.id}-v1`);
          } catch (error) {

          }
        }
      }

      populateHints() {
        var cell, i, len, ref, startingCell;
        ref = this.grid.querySelectorAll('td');
        for (i = 0, len = ref.length; i < len; i++) {
          startingCell = ref[i];
          if (startingCell.getAttribute("data-hint-vertical") === '.') {
            startingCell.setAttribute("data-hint-vertical", ((function() {
              var j, len1, ref1, results;
              ref1 = this.wordAfterCursor(this.cursorAt(startingCell), vertical);
              results = [];
              for (j = 0, len1 = ref1.length; j < len1; j++) {
                cell = ref1[j];
                results.push(cell.textContent);
              }
              return results;
            }).call(this)).join(''));
          }
          if (startingCell.getAttribute("data-hint-horizontal") === '.') {
            startingCell.setAttribute("data-hint-horizontal", ((function() {
              var j, len1, ref1, results;
              ref1 = this.wordAfterCursor(this.cursorAt(startingCell), horizontal);
              results = [];
              for (j = 0, len1 = ref1.length; j < len1; j++) {
                cell = ref1[j];
                results.push(cell.textContent);
              }
              return results;
            }).call(this)).join(''));
          }
        }
      }

      saveV1() {
        var cell, e, row, saveString;
        saveString = ((function() {
          var i, len, ref, results;
          ref = this.grid.rows;
          results = [];
          for (i = 0, len = ref.length; i < len; i++) {
            row = ref[i];
            results.push(((function() {
              var j, len1, ref1, results1;
              ref1 = row.cells;
              results1 = [];
              for (j = 0, len1 = ref1.length; j < len1; j++) {
                cell = ref1[j];
                results1.push(cell.textContent);
              }
              return results1;
            })()).join(','));
          }
          return results;
        }).call(this)).join(';');
        try {
          localStorage.setItem(`coffeeword-${this.container.id}-v1`, saveString);
        } catch (error) {
          e = error;
        }
        return saveString;
      }

      loadV1(string) {
        var cellString, col, i, j, len, len1, ref, ref1, row, rowString;
        ref = string.split(';');
        for (row = i = 0, len = ref.length; i < len; row = ++i) {
          rowString = ref[row];
          ref1 = rowString.split(',');
          for (col = j = 0, len1 = ref1.length; j < len1; col = ++j) {
            cellString = ref1[col];
            this.cellAfter({row, col}).textContent = cellString;
          }
        }
      }

      save() {
        return this.saveV1();
      }

      load() {
        var params, saveString;
        try {
          params = new URL(location).searchParams;
          if (params.has(`${this.container.id}-v1`)) {
            saveString = params.get(`${this.container.id}-v1`);
          } else {
            saveString = localStorage.getItem(`coffeeword-${this.container.id}-v1`);
          }
        } catch (error) {

        }
        if (saveString != null) {
          return this.loadV1(saveString);
        }
      }

      check() {
        var solutionHash;
        solutionHash = this.grid.getAttribute('data-solution-hash-v1');
        return solutionHash === this.currentHash();
      }

      currentHash() {
        return hash(this.saveV1());
      }

      gridHTML() {
        var html, temp;
        this.blur();
        this.grid.setAttribute('data-solution-hash-v1', this.currentHash());
        this.populateHints();
        temp = this.saveV1();
        this.clear(false);
        html = this.grid.outerHTML;
        this.loadV1(temp);
        return html;
      }

    };

    Kreuzwort.featuresFull = {
      check: true,
      clear: true,
      print: true,
      hintListing: true,
      writeNewCells: false,
      setBars: false,
      createGrid: false
    };

    Kreuzwort.featuresCompact = {
      check: true,
      clear: true,
      print: false,
      hintListing: false,
      writeNewCells: false,
      setBars: false,
      createGrid: false
    };

    Kreuzwort.featuresConstruction = {
      check: false,
      clear: true,
      print: false,
      hintListing: true,
      writeNewCells: true,
      setBars: true,
      createGrid: true
    };

    Kreuzwort.languages = {
      english: english,
      german: german
    };

    return Kreuzwort;

  })();

  window.Kreuzwort = Kreuzwort;

}).call(this);
